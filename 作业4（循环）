/*0-1背包*/
#include "stdio.h"
#define N 100
 
int main()
{
     void Knapsack(int [],int [],int ,int ,int [][1000]);
     void Traceback(int [],int [],int ,int ,int [][1000],int []);
     int n,i,c,v[N+1],w[N+1],m[N+1][1000],x[N+1];
     //v[]:价值,w[]:重量,c:背包可容纳重量,n:物品件数
     //m[][]:存放最大总价值的数组
     //m[i][j]表示背包容量为j,可选择物品为i,i+1,...,n时0-1背包问题的最优值
     //x[i]表示是否放入第i件物品，1为是，0为否
     printf("input n:");
     scanf("%d",&n);
     printf("input c:");
     scanf("%d",&c);
     printf("input v:");
     for(i=1;i<=n;i++) scanf("%d",&v[i]);
     printf("input w:");
     for(i=1;i<=n;i++) scanf("%d",&w[i]);
     Knapsack(v,w,c,n,m);
     Traceback(v,w,c,n,m,x);
     printf("answer:%d\n",m[1][c]);
     for(i=1;i<=n;i++)
       if(x[i]) printf("%d ",i);
     printf("\n");
     
     return 0;
 }
 
void Knapsack(int v[],int w[],int c,int n,int m[][1000])
 //v[]:价值,w[]:重量,c:背包可容纳重量,n:物品件数
 //m[][]:存放最大总价值的数组
 //m[i][j]表示背包容量为j,可选择物品为i,i+1,...,n时0-1背包问题的最优值
{
     int i,j,t;
     int jMax; 
     jMax=w[n]-1<=c? w[n]-1:c;
     //jMax是使m[n][x]为0的x最后下标
     for(j=0;j<=jMax;j++) m[n][j]=0;
     //对于背包容量k(0<=k<=jMax),物品n是超重的,故在这些容量下,一定不会选择物品n
     //故(m[n][0],m[n][1],...m[n][jMax-1],m[n][jMax]) = 0
     for(j=w[n];j<=c;j++) m[n][j]=v[n];
     //对于背包容量k(w[n]<=k<=c),物品n是可容纳的,故在这些容量下,选择物品n
     //以下是前面两个for循环的实例：
     //例1:n=6,w[6]=9,c=12,则(m[6][0],m[6][1],m[6][2],...m[6][7],m[6][8])=0
                           // (m[6][9],...m[6][12]=v[6]
     //例2:n=6,w[6]=9,c=8,则(m[6][0],m[6][1],m[6][2],...m[6][8],m[6][9])=0
     
     //到此为止，已经求出可选择物品只有第n件时在重量k(0<=k<=c)情况下的最优值
     //接下来求可选择物品为(第n-1件、第n件)，(第n-2件、第n-1件、第n件)，...，(第2件、第3件...第n件) 在重量k(0<=k<=c)情况下的最优值
     for(i=n-1;i>1;i--)
     {
         jMax=w[i]-1<=c? w[i]-1:c;
         //jMax是使m[i][x]为0的x最后下标
         for(j=1;j<=jMax;j++) m[i][j]=m[i+1][j];
         //对于背包容量k(0<=k<=jMax),物品i是超重的,在这些容量下，一定不会选择物品i
         //即(m[i][1]=m[i+1][1],m[i][2]=m[i+1][2],...,m[i][jMax]=m[i+1][jMax];
         for(j=w[i];j<=c;j++) 
         {
             //对于背包容量k(w[i]<=k<=c),物品i是可容纳的,但是否一定选择物品i?
             t=w[i];
             m[i][j]=m[i+1][j]>=m[i+1][j-t]+v[i]?m[i+1][j]:m[i+1][j-t]+v[i];
            //以上语句你能看明白，这是0-1背包模型的关键
         }
         //到此为止，已经求出可选择物品为(第n-1件、第n件)，(第 n-2件、第n-1件、第 n件)，...，(第 2件、第 3件...第 n 件) 在重量 k(0<=k<=c)情况下的最优值
         //接下来是求可选择物品为(第 1件、第 2件...第 n件) 在重量 k(0<=k<=c)情况下的最优值吗？
         //No!只需求可选择物品为(第 1件、第 2件...第 n件) 在重量 c(真正的背包容量)下的最优值
         m[1][c]=m[2][c]; //假设不放入第一件物品
         t=w[1];
         if(w[1]<=c) m[1][c]=m[1][c]>=m[2][c-t]+v[1]?m[1][c]:m[2][c-t]+v[1];
         //可以容纳第一件物品的情况下，该如何选择？
     }
 }
 
void Traceback(int v[],int w[],int c,int n,int m[][1000],int x[])
{
     //v[]:价值,w[]:重量,c:背包可容纳重量,n:物品件数
     //m[][]:存放最大总价值的数组
     //m[i][j]表示背包容量为j,可选择物品为i,i+1,...,n时0-1背包问题的最优值
     //x[i]表示是否放入第i件物品，1为是，0为否
     int i;
     for(i=1;i<n;i++)
       if(m[i][c]==m[i+1][c]) x[i]=0;
       //可选择物品中有第i件物品或没有第i件物品，最优值都是一样的，故一定没有放入第 i件物品
       else 
       {
             x[i]=1;
             c=c-w[i];
             //这个语句很重要，为判断是否选择了第 i+1件物品做准备
       }
       if(m[n][c]>0) //单独判断是否选择了第 n件物品
          x[i]=1;    
       else x[i]=0;
}
